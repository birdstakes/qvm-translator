from opcodes import *

class ILNode:
    def __init__(self, *children):
        self.children = list(children)

    @property
    def left(self):
        return self.children[0]

    @property
    def right(self):
        return self.children[1]

    @property
    def child(self):
        return self.children[0]

    def __repr__(self):
        return f'{self.__class__.__name__}'

    def __str__(self):
        return self.__repr__()

class ILInstruction(ILNode):
    def __init__(self, instruction, *children):
        super().__init__(*children)
        self.instruction = instruction
        self.opcode = instruction.opcode
        self.value = instruction.operand

    def __repr__(self):
        return f'{self.__class__.__name__} {mnemonics.get(self.opcode, str(self.opcode))}'

class ILLoad(ILInstruction):
    def __init__(self, instruction, *children):
        super().__init__(instruction, *children)
        self.size = 1 << (instruction.opcode - LOAD1)

class ILStore(ILInstruction):
    def __init__(self, instruction, *children):
        super().__init__(instruction, *children)
        self.size = 1 << (instruction.opcode - STORE1)

class ILLoadVar(ILNode):
    def __init__(self, var):
        super().__init__()
        self.var = var

class ILStoreVar(ILNode):
    def __init__(self, var, *children):
        super().__init__(*children)
        self.var = var

"""
# unary/binary op instructions should become these
# add cast nodes if child types don't match?
class ILUnaryOp(ILNode):
    pass

class ILBinaryOp(ILNode):
    pass
"""

# based on NodeVisitor from cpython's ast module
class ILVisitor:
    def visit(self, node):
        method = 'visit_' + node.__class__.__name__
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception(f'No visit_{node.__class__.__name__} method')

class ILTransformer:
    def visit(self, node):
        for i, child in enumerate(node.children):
            new_node = self.visit(child)
            if new_node is not None:
                node.children[i] = new_node

        method = 'visit_' + node.__class__.__name__
        visitor = getattr(self, method, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        pass

def il_to_string(node, indent=0):
    res = f'{" "*indent*4}{mnemonics[node.opcode]}'
    if node.value is not None:
        res += f' {node.value:#x}'
    for child in node.children:
        res += '\n' + il_to_string(child, indent+1)
    return res

def build_il(block):
    """Build a list of IL nodes from a basic block.

    This can't handle cases like this:
    
            ...
            EQ b
        a:
            CONST 1
            CONST c
            JUMP
        b:
            CONST 2
        c:
            (1 or 2?)
    
    Luckily, code generated by lcc seems to always have an empty opstack at
    basic block boundaries.
    """

    stack = []
    nodes = []

    for instruction in block.code:
        opcode = instruction.opcode

        if opcode == ENTER:
            nodes.append(ILInstruction(instruction))

        elif opcode in (PUSH, CONST, LOCAL):
            stack.append(ILInstruction(instruction))

        elif LOAD1 <= opcode <= LOAD4:
            stack.append(ILLoad(instruction, stack.pop()))

        elif STORE1 <= opcode <= STORE4:
            tos, nis = stack.pop(), stack.pop()
            nodes.append(ILStore(instruction, nis, tos))

        elif opcode == BLOCK_COPY or opcode in comparison_ops:
            tos, nis = stack.pop(), stack.pop()
            nodes.append(ILInstruction(instruction, nis, tos))

        elif opcode in (JUMP, LEAVE):
            nodes.append(ILInstruction(instruction, stack.pop()))

        elif opcode == ARG:
            nodes.append(ILInstruction(instruction, stack.pop()))

        elif opcode == CALL:
            stack.append(ILInstruction(instruction, stack.pop()))

        elif opcode == POP:
            # If we're popping the result of a CALL, make it a statement.
            # Otherwise, ignore pops.
            tos = stack.pop()
            if tos.opcode == CALL:
                nodes.append(tos)

        elif opcode in unary_ops:
            stack.append(ILInstruction(instruction, stack.pop()))

        elif opcode in binary_ops:
            tos, nis = stack.pop(), stack.pop()
            stack.append(ILInstruction(instruction, nis, tos))

        else:
            raise Exception(f'unhandled opcode {mnemonics[opcode]}')

    return nodes
